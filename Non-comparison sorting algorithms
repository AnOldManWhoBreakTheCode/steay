#include <iostream>
#include <cmath>
#include <queue>

void counting_sort(int* A, int k, int n){
    //배열 A의 원소의 개수를 원소의 값을 가진 인덱스에 집어 넣는다.
    //A n is size of array A and a k is max number of array A
    int count[k+1] = {0,};  // The index is in range from 0 to k
    int key = 0;
    int sorted_arr[n];
    
    for(int i = 0; i < n; i++){
        key = A[i];
        count[key] = count[key] + 1;
    }//counting of the number of each element

    count[0]--;
    //for to start index with zero
    for(int i = 1; i <= k; i++){
        //어짜피 시간복잡도 분석은 필수다...
        count[i] = count[i] + count[i - 1];
    }

    for(int i = n - 1; i >= 0; i--){
        key = A[i];
        sorted_arr[count[key]] = key;
        count[key]--;
    }

    for(int i = 0; i < n; i++){
        A[i] = sorted_arr[i];
    }
}

void print_arr(int* A, int n){
    std::cout<<"배열의 원소 출력"<<std::endl;

    for(int i = 0; i < n; i ++){
        std::cout<< A[i] <<" ";
    }

    std::cout<<std::endl;
}


int digits(int data, int i){
    int digit = 0;
    digit = data / pow(10, i - 1);
    digit = digit % 10;

    return digit;
}//i 번째 자리의 숫자를 구하는 함수.

void radix_sort(int* A, int n, int w){
    std::queue<int> q[10];
    int d = 0, p = 0;
    for(int i = 1; i <= w; i++){
        for(int j = 0; j < n; j++){
             d = digits(A[j], i);
             q[d].push(A[j]);
        }
        p = 0;
        for(int j = 0; j <= 9; j++){
            while(!q[j].empty()) {//q가 빌 때까지.
                A[p++] = q[j].front();
                q[j].pop();
            }
        }
    }
}

int main(){

    int A[] = {95956, 4545, 26 ,8989, 63,5 ,15669, 656};

    print_arr(A, 8);

    radix_sort(A, 8, 5);

    print_arr(A, 8);
    
    
    return 0;
}
